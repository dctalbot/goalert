// import urlBase64ToUint8Array from './util/urlBase64ToUint8Array'

// Register a Service Worker.
export function register() {
  navigator.serviceWorker.register('./sw.js')

  navigator.serviceWorker.ready
    .then(registration => {
      // Use the PushManager to get the user's subscription to the push service.
      return registration.pushManager.getSubscription().then(subscription => {
        // If a subscription was found, return it.
        // if (subscription) {
        //   return subscription;
        // }

        // Get the server's public key
        // const response = await fetch("./vapidPublicKey");
        // const vapidPublicKey = await response.text();
        const vapidPublicKey =
          'BG1eCfGcKyecTf7adIrdMtd3eRkHnr_nObrxw_ntuUcH9LSdW5W-IqEo7DdPul2Kwh1bpBL4jP9DI7NfYc691Rc'
        // Chrome doesn't accept the base64-encoded (string) vapidPublicKey yet
        // urlBase64ToUint8Array() is defined in /tools.js
        // const convertedVapidKey = urlBase64ToUint8Array(vapidPublicKey)

        // Otherwise, subscribe the user (userVisibleOnly allows to specify that we don't plan to
        // send notifications that don't have a visible effect for the user).
        return registration.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: vapidPublicKey,
        })
      })
    })
    .then(subscription => {
      // Send the subscription details to the server using the Fetch API.
      // fetch("./register", {
      //   method: "post",
      //   headers: {
      //     "Content-type": "application/json"
      //   },
      //   body: JSON.stringify({
      //     subscription: subscription
      //   })
      // });

      document.getElementById('doIt').onclick = () => {
        // const Keys = {
        //   Auth: subscription.getKey("auth"),
        //   P256dh: subscription.getKey("p256dh")
        // };
        // const Endpoint = subscription.endpoint;

        const payload = JSON.stringify(subscription)

        // Ask the server to send the client a notification (for testing purposes, in actual
        // applications the push notification is likely going to be generated by some event
        // in the server).
        fetch('http://localhost:8887/sendNotification', {
          method: 'post',
          headers: {
            'Content-type': 'application/json',
          },
          body: payload,
        })
      }
    })
}

export function unregister() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready.then(registration => {
      registration.unregister()
    })
  }
}

/// ////snippets
// if (Notification.permission == "granted") {
//   navigator.serviceWorker.getRegistration().then(reg => {
//     // TODO 2.4 - Add 'options' object to configure the notification

//     reg.showNotification("Hello world!");
//   });
// }

self.addEventListener('push', event => {
  event.waitUntil(
    self.registration.showNotification('Push Notification', {
      body: 'Alea iacta est',
    }),
  )
})

self.addEventListener('fetch', event => {
  event.waitUntil(
    self.registration.showNotification('Push Notification', {
      body: 'fetching',
    }),
  )
})
